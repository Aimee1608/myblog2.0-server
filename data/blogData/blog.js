const list = [
  {
    title: 'video 字幕texttrack属性的应用',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['6141f4a1cf2bf81fbbe21443'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "#### 定义和用法\naddTextTrack() 方法创建和返回新的文本轨道。\n\n新的 TextTrack 对象会被添加到视频/音频元素的文本轨道列表中。\n\n#### 语法\naudio|video.addTextTrack(kind,label,language)\n#### 参数\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-3ccefee2fe0724b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 展示效果\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-f9f2ddee3dee0384.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 文本形式添加\n以文本的形式添加：\n\n```html\n  <video id=\"video1\" controls src=\"./video/friday.mp4\">\n    <track default kind=\"captions\" srclang=\"zh-cn\" src=\"./video/friday.1.vtt\"/>\n  </video>\n```\n\n可以设置字幕样式\n```css\nvideo::cue {\n     background-image: linear-gradient(to bottom, dimgray, lightgray);\n     color: papayawhip;\n   }\n   video::cue(b) {\n     color: peachpuff;\n   }\n```\n而文件里面的内容：\n```\nWEBVTT\n\n00:00:00.000 --> 00:00:00.999  line:80%\n\bhi aimee!\n\n00:00:01.000 --> 00:00:01.499 line:80%\n你好吗?\n\n00:00:01.500 --> 00:00:02.999 line:80%\n大佬心情不好吗?\n\n00:00:03.000 --> 00:00:04.299 line:80%\n是的，他心情不好\n\n00:00:04.300 --> 00:00:06.000 line:80%\n一定是有人惹他生气了\n```\n#### 动态添加字幕\n另外一种动态添加字幕模式：\n首先，video标签\n```\n<video id=\"video1\" controls src=\"./video/friday.mp4\">\n```\n获取video dom ，添加文本轨道\n```\nmyVid=document.getElementById(\"video1\");     \nvar subtitles = myVid.addTextTrack(\"subtitles\", 'text','en');\n```\n设置文本标签的属性：\n```\nsubtitles.mode = 'showing'\n```\n将对应的字幕文本添加到文本轨道\n```\nvar titles = [\n        {\n          begintime: 0,\n          endtime:0.999,\n          text: '\baimee!'\n        },\n        {\n          begintime: 1,\n          endtime:1.499,\n          text: '\bHow are you?'\n        },\n        {\n          begintime: 1.5,\n          endtime:2.999,\n          text: '\bTell me, is the lord of the universe in?'\n        },\n        {\n          begintime: 3,\n          endtime:4.299,\n          text: \"Yes, he's in - in a bad humor\"\n        },\n        {\n          begintime: 4.3,\n          endtime: 6,\n          text: \"Somebody must've stolen the crown jewels\"\n        }\n      ]\n      for (var i = 0; i< titles.length; i++){\n        var item = titles[i]\n        var cue = new VTTCue(item.begintime, item.endtime, item.text);\n        cue.line = 80\n        subtitles.addCue(cue);\n      }\n```\n这样在视频播放的时候就能正常展示对应的字幕。\n\n#### 扩展\n从上述的字幕添加的必要属性中可以看出，需要开始时间、结束时间、以及展示的内容 这样就是一条字幕，在视频播放过程中，会根据对应的时间添加到现有展示队列中，到结束时间则移除，同时有一个oncuechange事件来监听每段字幕的添加和移除。\n知道上述属性后，我们可以利用该属性做一些类似字幕触发的事情，比如在某些时间段处理某些交互事情。\n\n具体如下\n```\nvar events = [\n          {\n            \"category\": 2,\n            \"begintime\": 1,\n            \"id\": \"139127\",\n            \"name\": '事件1'\n          },\n          {\n            \"category\": 1,\n            \"begintime\": 661,\n            \"endtime\": 783,\n            \"id\": \"433324\",\n            \"name\": '事件2',\n            \"date\": \"2019-05-12\",\n            \"timer\": 120,\n            \"type\": \"1\",\n            \"content\": \"https://hw.xesimg.com/2019/05/12/15576457373351jpg\",\n            \"audio\": \"\",\n            \"answer\": \"A\",\n            \"status\": 0\n          },\n          {\n            \"category\": 1,\n            \"begintime\": 1084,\n            \"endtime\": 1211,\n            \"id\": \"433325\",\n            \"name\": '事件3',\n            \"date\": \"2019-05-12\",\n            \"timer\": 120,\n            \"type\": \"1\",\n            \"content\": \"https://hw.xesimg.com/2019/05/12/15576457594631jpg\",\n            \"audio\": \"\",\n            \"answer\": \"B\",\n            \"status\": 0\n          },\n          {\n            \"category\": 2,\n            \"begintime\": 3539,\n            \"id\": \"139130\",\n            \"name\": '事件4',\n          }\n        ]\n      myVid=document.getElementById(\"video1\");      \n      var subtitles = myVid.addTextTrack(\"subtitles\", 'text','en');\n      for(var i=0;i<events.length;i++){\n        var item = events[i]\n        if(!item.endtime){\n          item.endtime = item.begintime+1\n        }\n        // subtitles.mode = 'showing' // 默认为隐藏不展示状态\n        subtitles.addCue(new VTTCue(item.begintime, item.endtime, JSON.stringify(events[i])));\n      }\n     console.log(myVid.textTracks)\n      \n      subtitles.oncuechange=function(text){\n        console.log('change',text)\n        console.log('activeCues', this.activeCues)\n        if(this.activeCues.length>0){\n          var tmpevent = JSON.parse(this.activeCues[0].text);\n          console.log('添加-----tmpevent', tmpevent)\n        } else {\n          console.log('移除')\n        }\n      } \n```\n字幕属性还有很多其他的属性值，可以参考[https://developer.mozilla.org/en-US/docs/Web/API/TextTrack](https://developer.mozilla.org/en-US/docs/Web/API/TextTrack)\n\n"
  },
  {
    title: 'vue event 源码浅析',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: '### 编译\n> 1、事件的编译是通过processAttrs这个方法来处理的；\n> 2、通过正则匹配元素绑定的事件类型、修饰符、对应的值；\n> 3、addHandler 函数，根据 modifier 修饰符对事件名 name 做处理，处理普通事件和原生事件，对name 做归类，返回处理后的AST；\n> 4、根据 AST 元素节点上的 events 和 nativeEvents 生成 data 数据；\n\n编译流程图如下\n\n![Xnip2019-04-18_21-59-04.jpg](https://upload-images.jianshu.io/upload_images/13238271-bdd012fcd91ab897.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### DOM 事件\n> 1、DOM事件是对原生事件的处理，最终通过原生的addEventListener 和removeEventListener 来实现监听和移除监听；\n> 2、updateListeners 的时候，会比较新旧事件回调的方法，如果存在只是改变引用，如果为新添加，则add，如果移除事件则remove;\n\n![Xnip2019-04-18_22-45-12.jpg](https://upload-images.jianshu.io/upload_images/13238271-780c6b360161f63e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 自定义事件\n#### 父子组件事件交互\n> 1、通过修饰符 区分native 还是非native 事件，非native事件赋值给listeners，native 事件赋值给data.on;\n> 2、data.on 事件的处理走上面原生DOM事件处理方式；\n> 3、listeners 通过对子组件添加_parentListeners；\n> 4、父组件通过updateListeners 的add move 来添加绑定事件，主要应用事件中心来实现；\n\n![20190419112701.png](https://upload-images.jianshu.io/upload_images/13238271-3ba69b84ddea409d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 事件中心\n\n\n![20190419120233.png](https://upload-images.jianshu.io/upload_images/13238271-9239c9172c76e8b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n'
  },
  {
    title: 'vue history 路由模式打包发布到服务器设置',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "### 要求描述\n页面访问地址\n首页：https://hello.haha.com/world\n用户中心 ：https://hello.haha.com/world/user\n\n### 路由设置\n\n路由配置js 设置 mode 为history ，这样会去掉#号 和正常的路由地址一样\n\n```js\nexport default new Router({\n  mode: 'history',\n  routes: [\n    {\n      path: '/world', // 注意 路由的path 需要和页面的地址保持一致，即域名后的二级目录都得一样,否则会报错\n      name: 'index',\n      component: index\n    },\n    {\n      path: '/world/user', \n      name: 'user',\n      component: user\n    },\n    {\n      path: '*',\n      redirect: {name: 'index'}\n    }\n  ]\n})\n\n```\n### ngix服务器配置\nvue官方文档推荐\n\n![在这里插入图片描述](http://upload-images.jianshu.io/upload_images/13238271-254dbe33ad451374?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 多层级目录的项目配置\n例如：项目区分pc  和 h5 项目，且两个项目为独立的\n主目录为：hello.haha.com\n层级：pc: /hello-pc/ \nh5: /hello-h5/\n用户访问链接：pc : https://hello.haha.com/hello-pc/world\n\t\t\t\t\t\t\t\thttps://hello.haha.com/hello-pc/world/user\n\t\t\t\t\t\t\t\t\n用户访问链接：h5 : https://hello.haha.com/hello-h5/world\n\t\t\t\t\t\t\t\thttps://hello.haha.com/hello-h5/world/user\n\n\nnginx 这时候可以这么配置：\n\n```nginx\nlocation /hello-pc/ {\n\ttry_files $uri $uri/ /hello-pc/index.html\n}\n\nlocation /hello-h5/ {\n\ttry_files $uri $uri/ /hello-h5/index.html\n}\n```\n"
  },
  {
    title: 'vue---子父、父子、非父子组件通信',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "#### 子组件和父组件通信\n\n - 在父组件中使用子组件时自定义事件，设置该事件的回调函数\n - 在子组件中需要传数据给父组件时调用this.$emit触发上面自定义的事件，并且设置要发生给父组件的数据\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <p>展示子组件的数据：{{pMsg}}</p>\n        <hr/>\n        <my-component v-on:my-click=\"show\"></my-component>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script>\n        //父组件--->使用子组件时通过自定义属性携带值--->子组件通过props接收自定义属性的值\n        //子组件和父组件通信：\n        //  在父组件中使用子组件时自定义事件，设置该事件的回调函数\n        //  在子组件中需要传数据给父组件时调用this.$emit触发上面自定义的事件，并且设置要发生给父组件的数据\n\n        //组件定义\n        const MyComponent={//组件选项\n            template:`<div>\n                    <input v-model=\"msg\"/>\n                    <button @click=\"send\">发送数据给父组件</button>\n                </div>`,\n            data(){\n                return {\n                    msg:'hello'\n                }\n            },\n            methods:{\n                send(){\n                    //发送是数据给父子组件\n                    //参数1指定的事件\n                    //参数2...:发送给对应事件回调函数的数据\n                    this.$emit('my-click',this.msg);//触发某个事件执行\n\n                }\n            }\n        }\n\n        new Vue({\n            el:\"#app\",\n            components:{\n                MyComponent     //等效于：MyComponent:MyComponent\n            },\n            data:{\n                pMsg:''\n            },\n            methods:{\n                show(param1){\n                    console.log('接收到了子组件的数据...',param1);\n                    this.pMsg=param1;//将子组件的数据赋值给父组件\n                }\n            }\n        })\n    </script>\n</body>\n</html>\n```\n#### 父子组件通信\n父组件可以使用props属性将值传给子组件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <my-component></my-omponent>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script>\n        //定义组件\n        const myComponent={\n            template:`<div>\n                    <h1>{{title}}</h1>\n                    <ul>\n                        <li v-for=\"d in list\">{{d.name}}</li>\n                    </ul>\n                </div>`,\n           \n            //props:['title','list']\n            //设置props验证\n            props:{\n                //key(所接收到的数据)\n                title:{\n                    type:String,\n                    // required:true\n                    default: 'hello'\n                }\n            }\n        }\n\n        new Vue({\n            el:\"#app\",\n            components:{\n                myComponent\n            }\n        })\n    \n    </script>\n</body>\n</html>\n```\n\n#### 非父子组件通信\n> 有两种方法：1）使用第三方来处理，new vue()；2）使用vuex 状态管理模式\n\n下面主要讲解使用事件总线来管理\n\n\n * 发送方：\n\t+ 通过bus.$emit触发事件，并且将数据作为参数发给接收放\n   + bus.$emit('my-send',val);\n - 接收方：\n    + 通过bus.$on监听事件，监听时设置回调函数，当事件触发时该回调函数就要调用\n    + bus.$on('my-send',function(val){ console.log('收到了发送方的数据',val) })\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <my-component1></my-component1>\n        <hr/>\n        <my-component2></my-component2>\n    </div>\n    <script src=\"./vue.js\"></script>\n    <script>\n        /**\n         * 非父子：1)使用new Vue()作为事件总线实现各个组件间的通信\n         *        2)使用Vuex 状态管理模式实现非父子间的通信\n         * \n         * 假设：MyComponent1发送'hello,组件2'给MyComponent2\n         */\n        const bus=new Vue();//创建空的Vue实例充当事件总线\n        /**\n         * 发送方：\n         *     通过bus.$emit触发事件，并且将数据作为参数发给接收放\n         *      bus.$emit('my-send',val);\n         * 接收方：\n         *     通过bus.$on监听事件，监听时设置回调函数，当事件触发时该回调函数就要调用\n         *      bus.$on('my-send',function(val){\n         *              console.log('收到了发送方的数据',val)\n         *          })\n         */\n\n        const MyComponent1={\n            template:`<div>\n                            <h1>组件1</h1>\n                            <button @click=\"send\">发送数据给组件2</button>\n                        </div>`,\n            data(){\n                return {\n                    msg:'hello,组件2'\n                }\n            },\n            methods:{\n                //发送数据\n                send(){\n                    bus.$emit('my-send',this.msg);\n                }\n            }\n        }\n\n        const MyComponent2={\n            template:`\n                <div>\n                    <h2>组件2..</h2>\n                    <p>{{msg}}</p>\n                </div>\n            `,\n            data(){\n                return {\n                    msg:''\n                }\n            },\n            created() {\n                //接收数据\n                bus.$on('my-send',(val)=>{\n                    this.msg=val\n                })\n            },  \n        }\n        new Vue({\n            el:\"#app\",\n            components:{\n                MyComponent1,\n                MyComponent2\n            }\n        })\n    </script>\n</body>\n</html>\n```\n"
  },
  {
    title: 'vue2.0 生命周期浅出',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "官网生命周期图\n\n![20190306183354570.png](https://upload-images.jianshu.io/upload_images/13238271-d6932b0e8097879f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nVue实例的生命周期：\n##### 挂载阶段：\n- new Vue()调用构造函数 \n- 初始化生命周期钩子函数\n- 调用this.beforeCreate钩子函数\n- 监听数据、初始化方法、调用计算属性产生依赖数据\n- 调用this.created钩子函数\n- 判断有没有设置el属性 （如果没有el等待vm.$mount('CSS选择器')）\n    如果设置过el属性或者调用$mount方法，则继续，否则结束了生命过程\n- 判断是否有template属性\n- 如果有，则template指定的视图为模版\n- 如果没有，则以el或$mount指定的节点的outerHTML为视图模版\n- 编译模版\n- 调用this.beforeMount钩子函数\n- 将编译的模版挂载到真实的DOM上\n- 调用this.mounted钩子函数,在mounted钩子函数中一般进行DOM的初始化\n\n##### 更新阶段：\n- 数据发生变化\n- setter方法\n- 通知watcher\n-  回调this.beforeUpdate钩子函数\n- 触发虚拟DOM（re-render）\n- 更新真实DOM\n- 回调this.updated钩子函数\n\n##### 销毁阶段：\n- 主动销毁(调用vm.$destroy())或被动销毁\n- 销毁前会调用this.beforeDestroy();\n- 销毁\n- 销毁后调用this.destroyed()\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <input type=\"text\" v-model=\"msg\">\n        <p id=\"box\">{{msg}}</p>\n        <button @click=\"change\">按钮</button>\n    </div>\n\n    <script src=\"./vue.js\"></script>\n    <script>\n        \n        var vm=new Vue({\n        //    el:\"#app\",\n        //    template:\"<div id='box'><h1>{{msg}}</h1></div>\",    //定义当前Vue实例所解析的视图模版\n            data:{\n                msg:'hello',\n                provs:\"11111\"\n            },\n            methods:{\n                show(){\n                    console.log('show....');\n                },\n                change(){\n                    this.provs=2222222+Math.random();\n                    console.log(this.provs);\n                }\n            },\n            computed:{\n                newMsg(){\n                    return this.msg+',zhangsan';\n                }\n            },\n            //生命周期钩子函数:在Vue创建过程中会被自动回调函数\n            beforeCreate() {\n                console.log('breforeCreate...',this.msg,this.show,this.newMsg);//当前Vue实例对象\n            },\n            created() {\n                console.log('created...',this.msg,this.show,this.newMsg);//当前Vue实例对象\n            },\n            beforeMount() {\n                console.log('beforeMount....',this.$el);\n            },\n            mounted() {\n                console.log('mounted....',this.$el);\n            },\n            beforeUpdate() {\n                console.log('beforeUpdate....',this.msg)\n            },\n            updated() {\n                console.log('updated....',this.msg)\n            },\n            beforeDestroy() {\n                console.log('beforeDestroy....')\n            },\n            destroyed() {\n                console.log('destroyed.....')\n            },\n        });\n        vm.$mount(\"#app\") //替代el属性，指定Vue实例挂载的节点\n    </script>\n</body>\n</html>\n```\n"
  },
  {
    title: 'Vue 封装 自定义toast 插件并随处调用',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "### toast插件功能说明\n1、展示一条提示消息，显示3s 中或者其他时间后消失\n2、消息为自定义消息，展示多条消息，展示最新的消息\n3、可关闭当前展示的消息\n\n### 开发说明\n##### 目录结构\n首先在vue 项目中src 目录下，创建plugins目录，存放插件内容\n\n```tree\n── plugins\n│   │   └── ToastMessage\n│   │       ├── index.js\n│   │       └── index.vue\n\n```\n\n\n##### .vue组件内容\n承载组件的内容，在@/plugins/ToastMessage/index.vue文件里\n我需要的内容不多，message 和show 来分别控制展示内容和展示与否\n\n```html\n<template>\n  <div class=\"toastMessageBox\" v-show=\"show\">{{message}}</div>\n</template>\n\n<script>\nimport {mapState} from 'vuex'\nexport default {\n  name: 'toastMessage',\n  data () {\n    return {\n      message: '',\n      show: false\n    }\n  }\n}\n</script>\n\n<style lang='less' scoped>\n.toastMessageBox{\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n  transform: translate(-50%, -50%);\n  background-color: rgba(0, 0, 0, 0.8);\n  color: #fff;\n  padding: 8px;\n  font-size: 16px;\n  border-radius: 8px;\n  text-align: center;\n}\n</style>\n\n```\n##### 组件输出为插件\n通常，将上面的组件直接引入到父组件，这为组件的使用，如果是插件，需要将改组件export 并extend在Vue 实例上。\n将Vue 和上面的 组件引入进来\n\n```js\nimport Vue from 'vue'\nimport vueToastMessage from './index.vue'\n```\n将组件挂到Vue上，声明变量构造函数的变量、定时器的变量\n```js\nlet ToastTem = Vue.extend(vueToastMessage)\nlet instance\nlet timer = null\n```\n生成构造函数，挂载到dom元素上，避免重复生成多个构造函数，需判断是否已经存在；\n判断是否正在展示中，清空定时器，将展示的内容赋值为新内容；\n通过定时器来控制展示的时长，如果未传参数，默认为3s;\n```js\nlet toastMessage = (options) => {\n  if (!instance) {\n    instance = new ToastTem()\n    instance.vm = instance.$mount()\n    document.body.appendChild(instance.vm.$el)\n  }\n  console.log(options)\n  if (timer) {\n    clearTimeout(timer)\n    timer = null\n    instance.show = false\n    instance.message = ''\n  }\n  let time = 3000\n  if (typeof options === 'string') {\n    instance.message = options\n  } else if (typeof options === 'object') {\n    let {message, time} = options\n    instance.message = message\n    time = time || 3000\n  } else {\n    return\n  }\n  instance.show = true\n  timer = setTimeout(() => {\n    instance.show = false\n    clearTimeout(timer)\n    timer = null\n    instance.message = ''\n  }, time)\n}\n```\n关闭toast\n\n```js\ntoastMessage.close = () => {\n  if (timer) {\n    clearTimeout(timer)\n    timer = null\n    instance.show = false\n    instance.message = ''\n  }\n}\n```\n\n以上直接在末尾export default toastMessage，即可在元素中调用，调用方法：\n\n```js\nexport default toastMessage\n```\n##### 局部使用\n```js\nimport toastMessage from '@/plugins/ToastMessage'\ntoastMessage({message: '123', time: 3000})\n```\n##### 挂载到全局\n需要在export default toastMessageinstall,挂载到prototype\n\n```js\ntoastMessage.install = (Vue) => {\n  Vue.prototype.$toastMessage = toastMessage\n}\n```\n在main.js 中引入\n\n```js\nimport toastMessage from '@/plugins/ToastMessage' // message 提示消息插件\nVue.use(toastMessage)\n```\n##### 在组件中使用\n\n```js\nthis.$toastMessage({message: '33333', time: 3000})\n```\n完整的@/plugins/ToastMessage/index.js 文件内容如下：\n\n```js\nimport Vue from 'vue'\nimport vueToastMessage from './index.vue'\nlet ToastTem = Vue.extend(vueToastMessage)\nlet instance\nlet timer = null\nlet toastMessage = (options) => {\n  if (!instance) {\n    instance = new ToastTem()\n    instance.vm = instance.$mount()\n    document.body.appendChild(instance.vm.$el)\n  }\n  console.log(options)\n  if (timer) {\n    clearTimeout(timer)\n    timer = null\n    instance.show = false\n    instance.message = ''\n  }\n  let time = 3000\n  if (typeof options === 'string') {\n    instance.message = options\n  } else if (typeof options === 'object') {\n    let {message, time} = options\n    instance.message = message\n    time = time || 3000\n  } else {\n    return\n  }\n  instance.show = true\n  timer = setTimeout(() => {\n    instance.show = false\n    clearTimeout(timer)\n    timer = null\n    instance.message = ''\n  }, time)\n}\ntoastMessage.close = () => {\n  if (timer) {\n    clearTimeout(timer)\n    timer = null\n    instance.show = false\n    instance.message = ''\n  }\n}\ntoastMessage.install = (Vue) => {\n  console.log('install--------toastMessage')\n  Vue.prototype.$toastMessage = toastMessage\n}\nexport default toastMessage\n\n```\n"
  },
  {
    title: 'vue  ie11 strict 模式下不允许一个属性有多个定义',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: '#### 报错提示\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-de1e01880903f62c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 编辑器的重要性\n之前用atom 开发，并没有安装对应的错误提示，找了半天找不到原因\n后来换了个编辑器 用vscode 直接发现问题~~~~~~~~轮编辑器的重要性\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-0c2aee377ed1e90d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nvscode 编辑器所安装的插件\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-57fd4dffbf84fe39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n'
  },
  {
    title: 'vue 搭建后台系统模块化开发',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "### 效果\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-82b1da2e893538ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 目录结构\n\n```\n├── README.md\n├── build\n│   ├── build.js\n│   ├── check-versions.js\n│   ├── logo.png\n│   ├── utils.js\n│   ├── vue-loader.conf.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── src\n│   ├── App.vue\n│   ├── assets\n│   │   └── logo.png\n│   ├── components\n│   │   ├── HelloWorld.vue\n│   │   ├── header.vue\n│   │   ├── home.vue\n│   │   └── leftBanner.vue\n│   ├── main.js\n│   ├── router\n│   │   └── index.js\n│   └── views\n│       ├── active.vue\n│       ├── listOrder.vue\n│       ├── newOrder.vue\n│       ├── system.vue\n│       └── user.vue\n└── static\n```\n### 实现方法：\n#### 第一步：使用vue-cli 脚手架初始化项目文件，具体步骤参考 \n[vue.js 项目 环境搭建、运行、打包发布（常规版）](https://blog.csdn.net/Aimee1608/article/details/81044875)\n\n#### 第二步：封装头部、侧边栏和公共容器组件\n头部：用户信息等\n侧边栏：用的elment-ui 的导航栏\n公共容器：使用router-view 引入其他子页面，达到所有页面公用头部和侧边栏的效果\n\n```html\n<template>\n  <div>\n    <el-container>\n      <el-header>\n        <temHeader></temHeader>\n      </el-header>\n      <el-container>\n        <el-aside>\n          <temLeftBanner></temLeftBanner>\n        </el-aside>\n        <el-main >\n          <transition name=\"move\" mode=\"out-in\">\n            <router-view class=\"main-container\"></router-view>\n          </transition>\n        </el-main>\n      </el-container>\n    </el-container>\n  </div>\n</template>\n\n<script>\nimport temHeader from './header.vue'\nimport temLeftBanner from './leftBanner.vue'\nexport default {\n  data () {\n    return {\n\n    }\n  },\n  components: { // 组件\n    temHeader,\n    temLeftBanner\n  },\n  computed: { // 计算\n\n  },\n  methods: { // 方法事件\n\n  },\n  mounted () { // 加载完成\n\n  },\n  created () { // 创建\n\n  }\n}\n</script>\n\n<style lang='less'>\n.el-container{\n  height: 100vh;\n}\n.el-header, .el-footer {\n    background-color: #B3C0D1;\n    color: #333;\n    text-align: center;\n    line-height: 60px;\n}\n.el-aside {\n  background-color: #D3DCE6;\n  color: #333;\n  text-align: center;\n  line-height: 200px;\n}\n.el-main {\n  background-color: #E9EEF3;\n  color: #333;\n  text-align: center;\n}\n.main-container{\n  max-width: 800px;\n  margin: 0 auto;\n}\nbody > .el-container {\n  margin-bottom: 40px;\n}\n.el-container:nth-child(5) .el-aside,\n.el-container:nth-child(6) .el-aside {\n  line-height: 260px;\n}\n.el-container:nth-child(7) .el-aside {\n  line-height: 320px;\n}\n</style>\n\n```\n\n#### 第三步：内容页面\n\n```\n│   └── views\n│       ├── active.vue\n│       ├── listOrder.vue\n│       ├── newOrder.vue\n│       ├── system.vue\n│       └── user.vue\n```\n#### 第四步：路由\n使用children来区分路由地址\n```js\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport home from '@/components/home'\nimport listOrder from '@/views/listOrder'\nimport newOrder from '@/views/newOrder'\nimport active from '@/views/active'\nimport system from '@/views/system'\nimport user from '@/views/user'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      redirect: '/listOrder'\n    },\n    {\n      path: '/',\n      name: 'home',\n      component: home,\n      children: [\n        {\n          path: '/listOrder',\n          name: 'listOrder',\n          component: listOrder\n        },\n        {\n          path: '/newOrder',\n          name: 'newOrder',\n          component: newOrder\n        },\n        {\n          path: '/active',\n          name: 'active',\n          component: active\n        },\n        {\n          path: '/system',\n          name: 'system',\n          component: system\n        },\n        {\n          path: '/user',\n          name: 'user',\n          component: user\n        }\n      ]\n    }]\n})\n\n```\n\n项目地址：https://github.com/Aimee1608/vueCommonModule"
  },
  {
    title: 'vue keep-alive保存状态',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "# 使用vue的keep-alive属性设置页面保存状态\n\n应项目需求，开发一个类似app的移动端H5项目，有tabbar标签切换，并需要保存当前状态。之前对vue学习不够全面，并不了解keep-alive属性，再查询各种资料，终于看到了keep-alive，简单好用，不禁感叹vue真是强大。\n\n##keep-alive定义\nkeep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n##原理\n 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和transition 相似，keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n\n##prop\n\ninclude: 字符串或正则表达式。只有匹配的组件会被缓存。\nexclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。\n\n##常见用法\n\n\n- **用法——组件**\n\n```js\n// 组件\nexport default {\n  name: 'test-keep-alive',\n  data () {\n    return {\n        includedComponents: \"test-keep-alive\"\n    }\n  }\n}\n\n\n```\n\n```html\n<keep-alive include=\"test-keep-alive\">\n  <!-- 将缓存name为test-keep-alive的组件 -->\n  <component></component>\n</keep-alive>\n\n<keep-alive include=\"a,b\">\n  <!-- 将缓存name为a或者b的组件，结合动态组件使用 -->\n  <component :is=\"view\"></component>\n</keep-alive>\n\n<!-- 使用正则表达式，需使用v-bind -->\n<keep-alive :include=\"/a|b/\">\n  <component :is=\"view\"></component>\n</keep-alive>\n\n<!-- 动态判断 -->\n<keep-alive :include=\"includedComponents\">\n  <router-view></router-view>\n</keep-alive>\n\n<keep-alive exclude=\"test-keep-alive\">\n  <!-- 将不缓存name为test-keep-alive的组件 -->\n  <component></component>\n</keep-alive>\n```\n\n\n- **用法——结合router**\n结合router，缓存部分页面\n使用$route.meta的keepAlive属性：\n```html\n<keep-alive>\n    <router-view v-if=\"$route.meta.keepAlive\"></router-view>\n</keep-alive>\n<router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n\n```\n需要在router中设置router的元信息meta\n\n```js\n//...router.js\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'Hello',\n      component: Hello,\n      meta: {\n        keepAlive: false // 不需要缓存\n      }\n    },\n    {\n      path: '/page1',\n      name: 'Page1',\n      component: Page1,\n      meta: {\n        keepAlive: true // 需要被缓存\n      }\n    }\n  ]\n})\n```\n##效果\n如图：这个是vux 插件，效果正是如此，状态保留在内存中，防止重复渲染。\n那么问题来了，使用keep-alive缓存也会有弊端，会导致有些页面有些数据改变的时候，页面数据需要重新渲染，这时候可以配合watch 监听来解决。\n"
  },
  {
    title: 'vue.js 2.* 项目 环境搭建、运行、打包发布（常规版）',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: '## Vue 安装\n### vue-cli /webpack 全局安装\n如果在意安装速度，可以使用淘宝镜像来安装\n安装淘宝镜像\n **npm install -g cnpm --registry=https://registry.npm.taobao.org**\n\n安装完淘宝镜像后，就可以使用cnpm 来代替 npm  安装工具啦\n\n我个人比较喜欢直接使用npm 安装：\n\n全局webpack：\n **npm install webpack -g**\n\nvue脚手架vue-cli：\n**npm install vue-cli -g**\n\n### 安装webpack 版vue 项目\n在指定的目录中打开命令窗口（编辑器中自带的命令窗口也可以）\n**vue init webpack myvuedemo**\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-1a2aeb62c1e9d1e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n - Project name (回车默认)\n - Project description (A Vue.js project) 回车默认 （也可以输入自己的描述）\n - Author 回车默认（自己的名字）\n - Vue build 默认选择 Runtime+Compiler\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-fb5f615690358cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n- Install vue-router?Y 安装\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-8f4dabe303838882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n- Use ESLint to lint your code? Y (推荐使用，保持良好的代码编写规范)\n- pick an eslint preset. 默认 Standard\n- set up unit tests ？ n (unit 测试，不需要)\n- setup e2e tests with Nightwatch？n (e2e 测试，不需要）\n- Should we run `npm install` for you after the project has been created? (recom\nmended)  npm （选用 npm ）\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-91946243327a4982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n- 安装完毕 \n![image.png](https://upload-images.jianshu.io/upload_images/13238271-955d2b9a410dbe10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 目录结构\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-11a9ea20e748f908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## Vue 运行\n运行命令\n**cd myvuedemo**\n**npm run dev**\n### 运行成功\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-f8ac7afc10ea8a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 页面内容\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-2734112af9d83b92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## Vue build 打包\n\n打包命令\n**npm run build**\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-6b1a85ca67811451.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 打包后的目录结构\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-f44e833ce5d9b3e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 运行打包项目\n需要开启服务运行\n使用http-server 运行（如没有安装http-server的，使用node 全局安装 http-server 即可，npm install http-server -g）\n**cd dist**\n**http-server**\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-d0a22e40c763cc89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 运行打包后的内容\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-5ff421808d316b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n> 从搭建到运行打包发布全部完成，是不是很简单呢？\n\n\n>简单版的 vue.js 项目搭建 => https://blog.csdn.net/Aimee1608/article/details/78342914'
  },
  {
    title: 'Vue 应用中结合vux使用微信 jssdk',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "### vux微信分享说明\n分享接口只有认证公众号才能使用，域名必须备案且在微信后台设置。\n\n先确认已经满足使用jssdk的要求再进行开发。\n### 引入\n在 main.js 中全局引入：\n\n```js\nimport { WechatPlugin } from 'vux'\nVue.use(WechatPlugin)\n\nconsole.log(Vue.wechat) // 可以直接访问 wx 对象。\n```\n\n组件外使用\n考虑到你需要在引入插件后调用config方法进行配置，你可以通过 Vue.wechat 在组件外部访问wx对象。\n\njssdk需要请求签名配置接口，你可以直接使用 VUX 基于 Axios 封装的 AjaxPlugin\n```\nimport { WechatPlugin, AjaxPlugin } from 'vux'\nVue.use(WechatPlugin)\nVue.use(AjaxPlugin)\n\nVue.http.get('/api', ({data}) => {\n  Vue.wechat.config(data.data)\n})\n```\n组件中使用\n\n那么之后任何组件中都可以通过 this.$wechat 访问到 wx 对象。\n\n```\nexport default {\n  created () {\n    this.$wechat.onMenuShareTimeline({\n      title: 'hello VUX'\n    })\n  }\n}\n```\n我所使用的是组件外定义，组件内调用\n\n引入对应的文件\n\n```\nimport Vue from 'vue'\nimport { WechatPlugin } from 'vux'\nVue.use(WechatPlugin)//使用微信插件\n```\n\n```\n//微信分享\nconst wxShare = (obj,callback)=>{\n    // console.log(obj,callback);\n    function getUrl(){\n       var url = window.location.href;\n       var locationurl = url.split('#')[0];\n       //console.log(locationurl);\n\n       return locationurl;\n   }\n    if(obj){\n        var title = obj.title==undefined||obj.title==null?'泉水系统':obj.title;\n        var link = obj.link==undefined||obj.link==null?window.location.href:obj.link;\n        var desc = obj.desc==undefined||obj.desc==null?'泉水系统':obj.desc;\n        var imgUrl = obj.imgUrl==undefined||obj.imgUrl==null?'src/img/share.png':obj.imgUrl;\n        var debug = obj.debug==true?true:false;\n    }else{\n        alert('请传分享参数');\n    }\n    //微信分享\n    Vue.http.get(\"http://获取wx_token地址\").then(response => response.json()).then(data => {\n        // console.log('微信微信',data)\n        var wxdata = data;\n        wxdata.debug = debug;\n        wxdata.jsApiList= [\n            // 所有要调用的 API 都要加到这个列表中\n            'onMenuShareTimeline',//分享到朋友圈\n            'onMenuShareAppMessage',//分享给朋友\n            'onMenuShareQQ',//分享到QQ\n            'onMenuShareQZone',//分享到QQ空间\n            'onMenuShareWeibo'//分享到腾讯微博\n        ];\n        Vue.wechat.config(wxdata);\n\n\n        Vue.wechat.ready(function () {\n            //分享到朋友圈\n            Vue.wechat.onMenuShareTimeline({\n                title:title, // 分享标题\n                link: link, // 分享链接\n                desc: desc, // 分享描述\n                imgUrl:imgUrl, // 分享图标\n                success: function () {\n                    callback && callback();\n                    // 用户确认分享后执行的回调函数\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n            //分享到朋友\n            Vue.wechat.onMenuShareAppMessage({\n                title: title, // 分享标题\n                desc: desc, // 分享描述\n                link: link, // 分享链接\n                imgUrl: imgUrl, // 分享图标\n                type: '', // 分享类型,music、video或link，不填默认为link\n                dataUrl: '', // 如果type是music或video，则要提供数据链接，默认为空\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                    callback && callback();\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n            //分享到QQ\n            Vue.wechat.onMenuShareQQ({\n                title: title, // 分享标题\n                desc: desc, // 分享描述\n                link: link, // 分享链接\n                imgUrl: imgUrl, // 分享图标\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                    callback && callback();\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n\n            //分享到QQ空间\n            Vue.wechat.onMenuShareQZone({\n                title: title, // 分享标题\n                desc: desc, // 分享描述\n                link: link, // 分享链接\n                imgUrl: imgUrl, // 分享图标\n                success: function () {\n                   // 用户确认分享后执行的回调函数\n                   callback && callback();\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n\n            //分享到腾讯微博\n            Vue.wechat.onMenuShareWeibo({\n                title: title, // 分享标题\n                desc: desc, // 分享描述\n                link: link, // 分享链接\n                imgUrl: imgUrl, // 分享图标\n                success: function () {\n                    // 用户确认分享后执行的回调函数\n                    callback && callback();\n                },\n                cancel: function () {\n                    // 用户取消分享后执行的回调函数\n                }\n            });\n        })\n    })\n}\n```\n输出\n\n```\nexport {wxShare}\n```\n\n组件内调用\n\n```\nimport { wxShare } from '封装wxShare函数的js路径'\n    export default {\n        name:'Home',\n        data() { //选项 / 数import { ViewBox } from 'vux'\n    export default {\n        name:'Home',\n        data() { //选项 / 数据\n            return {\n\n            }\n        },\n        methods: { //事件处理器\n\n        },\n        components: { //定义组件\n            \n        },\n        created() { //生命周期函数\n\t\t\twxShare({\n              title: '分享标题', // 分享标题\n              desc: '分享描述', // 分享描述\n              link: window.location.href, // 分享链接\n              imgUrl: 'http://图片地址share.png', // 分享图标\n            //   debug:true\n          },function(){//分享成功后的回调函数\n\t\t\t\t\n          });\n        }\n   \n    }\n```\n"
  },
  {
    title: '搭建配置vux项目',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "### 强烈推荐vux插件，非常好用的移动端vue组件\n\n首先还是需要创建vue项目，然后再安装vux依赖\n\n### 开始创建vue项目             \n\n### VueJs操作命令\n\n-  安装一个框架： vue init webpack-simple vue_test\n- 安装各种模块：cnpm install\n\n### 如使用路由和网络请求 还需安装vue-router和vue-resource，全局状态vuex\n\n-  安装vue-router ：cnpm install vue-router --save\n- 安装vue-resource:  cnpm install vue-resource --save\n- 安装vue-vuex  cnpm install vue-vuex--save\n- 启动框架：    cnpm run dev\n已经可以运行啦\n \n#### 注：\n\ncnpm install模块名--save-dev(关于环境的，表现为npmrun dev 启动不了)\ncnpm install模块名 --save(关于项目的，比如main.js，表现为npm run dev 成功之后控制台报错)-S是简写\n\n#### 由于webpack打包时无法识别css，得安装以下模块，让webpack可以解析css文件\ncnpm install style-loader --save-dev\ncnpm install css-loader --save-dev\ncnpm install file-loader --save-dev\n\n#### 安装vux插件(官网上注明直接用nmp安装，cnpm 可能更新不及时)\n- 安装vux npm install vux --save\n- 安装vux-loader npm install vux-loader --save-dev\n\n完整安装配置表\n\n```json\n{\n  \"name\": \"xyspring\",\n  \"description\": \"spring xingyuan\",\n  \"version\": \"1.0.0\",\n  \"author\": \"aimee1608 <shuigongqian@sina.com>\",\n  \"license\": \"MIT\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot\",\n    \"build\": \"cross-env NODE_ENV=production webpack --progress --hide-modules\"\n  },\n  \"dependencies\": {\n    \"vue\": \"^2.5.11\",\n    \"vue-resource\": \"^1.5.0\",\n    \"vue-router\": \"^3.0.1\",\n    \"vuex\": \"^3.0.1\",\n    \"vux\": \"^2.8.0\"\n  },\n  \"browserslist\": [\n    \"> 1%\",\n    \"last 2 versions\",\n    \"not ie <= 8\"\n  ],\n  \"devDependencies\": {\n    \"babel-core\": \"^6.26.0\",\n    \"babel-loader\": \"^7.1.2\",\n    \"babel-preset-env\": \"^1.6.0\",\n    \"babel-preset-stage-3\": \"^6.24.1\",\n    \"cross-env\": \"^5.0.5\",\n    \"css-loader\": \"^0.28.7\",\n    \"extract-text-webpack-plugin\": \"^4.0.0-beta.0\",\n    \"file-loader\": \"^1.1.4\",\n    \"less\": \"^2.7.3\",\n    \"less-loader\": \"^4.1.0\",\n    \"style-loader\": \"^0.20.3\",\n    \"vue-loader\": \"^13.0.5\",\n    \"vue-template-compiler\": \"^2.4.4\",\n    \"vux-loader\": \"^1.2.2\",\n    \"webpack\": \"^3.6.0\",\n    \"webpack-dev-server\": \"^2.9.1\"\n  }\n}\n\n```\n\n#### webpack.config.js 配置\n 因为vux主要是组件居多，样式和组件的引用是基于vux-loader,需要设置vux-loader;\n 添加识别css less vux js的规则\n \n\n```js\n      {\n          test: /\\.css$/,\n          use: [\n            'vue-style-loader',\n            'css-loader'\n          ],\n        },      {\n          test: /\\.vue$/,\n          loader: 'vue-loader',\n          options: {\n            loaders: {\n            }\n            // other vue-loader options go here\n          }\n        },\n        {\n          test: /\\.js$/,\n          loader: 'babel-loader',\n          exclude: /node_modules/\n        },\n        {\n          test: /\\.(png|jpg|gif|svg)$/,\n          loader: 'file-loader',\n          options: {\n            name: '[name].[ext]?[hash]'\n          }\n        },\n        {\n              test: /\\.less$/,\n\n              loader: \"style-loader!css-loader!less-loader\",\n          },\n          {\n            test: /\\.(png|jpg|gif|svg|woff|ttf|eot|woff2)$/,\n            loader: 'file-loader',\n            options: {\n              name: '[name].[ext]?[hash]'\n            }\n        },\n          {\n            test: /vux.src.*?js$/,\n            loader: 'babel'\n          }\n\n```\n\n 完整配置如下：\n \n\n```js\nvar path = require('path')\nvar webpack = require('webpack')\nconst vuxLoader = require('vux-loader')\nlet webpackConfig = {\n    entry: './src/main.js',\n    output: {\n      path: path.resolve(__dirname, './dist'),\n      publicPath: 'dist/',\n      filename: 'build.js'\n    },\n    module: {\n      rules: [\n        {\n          test: /\\.css$/,\n          use: [\n            'vue-style-loader',\n            'css-loader'\n          ],\n        },      {\n          test: /\\.vue$/,\n          loader: 'vue-loader',\n          options: {\n            loaders: {\n            }\n            // other vue-loader options go here\n          }\n        },\n        {\n          test: /\\.js$/,\n          loader: 'babel-loader',\n          exclude: /node_modules/\n        },\n        {\n          test: /\\.(png|jpg|gif|svg)$/,\n          loader: 'file-loader',\n          options: {\n            name: '[name].[ext]?[hash]'\n          }\n        },\n        {\n              test: /\\.less$/,\n\n              loader: \"style-loader!css-loader!less-loader\",\n          },\n          {\n            test: /\\.(png|jpg|gif|svg|woff|ttf|eot|woff2)$/,\n            loader: 'file-loader',\n            options: {\n              name: '[name].[ext]?[hash]'\n            }\n        },\n          {\n            test: /vux.src.*?js$/,\n            loader: 'babel'\n          }\n\n      ]\n    },\n    resolve: {\n      alias: {\n        'vue$': 'vue/dist/vue.esm.js'\n      },\n      extensions: ['*', '.js', '.vue', '.json','.less']\n    },\n    devServer: {\n      historyApiFallback: true,\n      noInfo: true,\n      overlay: true\n    },\n    performance: {\n      hints: false\n    },\n    // devtool: '#cheap-module-source-map'\n}\n\nmodule.exports = vuxLoader.merge(webpackConfig, {\n  plugins: [{name:'vux-ui'},{name: 'duplicate-style'}]\n})\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports.devtool = '#source-map'\n  // http://vue-loader.vuejs.org/en/workflow/production.html\n  module.exports.plugins = (module.exports.plugins || []).concat([\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new webpack.optimize.UglifyJsPlugin({\n      sourceMap: true,\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.LoaderOptionsPlugin({\n      minimize: true\n    })\n  ])\n}\n\n```\n###入口文件\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport VueRouter from 'vue-router'\nimport VueResource from 'vue-resource'\nimport routes from './router/routes.js'//路由模块文件\n\nVue.use(Vuex)\nVue.use(VueRouter)\nVue.use(VueResource)\n\n\n\nconst router = new VueRouter({   \n    routes\n})\n\nvar vm = new Vue({\n  el: '#app',\n  router,\n  store\n})\n```\n### 路由模块\n\n```\nconst routes =[\n    {//首页\n        path:'/',\n        component: resolve => require(['../components/mainTem/Home.vue'],resolve),\n        meta:{auth:true,keepAlive: true },\n        name:'Home'\n    },//登录\n    {\n        path:'/Login',\n        component: resolve => require(['../components/mainTem/Login.vue'],resolve),\n        meta:{auth:true,keepAlive: false},\n        name:'Login'\n    }\n    ...\n]\n\nexport default routes\n```\n\n#### 组件引用\n按需引入\n\n```\n<template>\n\t<div>\n\t\t<group class=\"lo-phone info\" >\n              <x-input type=\"number\"  placeholder=\"输入手机号码\"   v-model=\"phone\" :min=\"11\" :max=\"11\"></x-input>\n            </group>\n\t</div>\n</template>\nimport { XInput, Group } from 'vux'\nexport default {\n  data() { //选项 / 数据\n            return {\n\t\t\t\tphone:15539383737\n\t\t}\n\t}\n  components: {\n    XInput，\n    Group\n  }\n}\n```"
  },
  {
    title: 'vue  router.beforeEach跳转路由验证用户登录状态',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "## 使用vue判断验证用户登录状态\n\n- **导航钩子类似于生命周期钩子，包含路由进入前，进入后，更新时，退出前等几个周期，主要用于控制导航的前进后退或跳转等。**\n- **其中router.beforeEach就是路由进入前的周期，同时有路由的来源和去向两个参数，可以判断和控制当前路由的走向和重定向。**\n\n- **一般router.beforeEach配合vuex全局状态储存使用，验证用户登录状态。也可以结合sessionStorage 和localStorage使用，原理相同。**\n\n### 用户登录状态验证\n\n### 路由配置\n\n定义需要判断登录状态的meta 属性auth\n```js\nconst routes =[\n    {\n        path:'/',\n        component: resolve => require(['../components/mainTem/Filtrate.vue'],resolve),\n        meta:{auth:true,keepAlive: false},\n        name:'Filtrate'\n    },//首页\n    {\n        path:'/Home',\n        component: resolve => require(['../components/mainTem/Home.vue'],resolve),\n        meta:{auth:true,keepAlive: true },\n        name:'Home'\n    },//登录\n    {\n        path:'/Login',\n        component: resolve => require(['../components/mainTem/Login.vue'],resolve),\n        meta:{auth:true,keepAlive: false},\n        name:'Login'\n    },//最新案例\n    {\n        path:'/NewCase',\n        component: resolve => require(['../components/mainTem/NewCase.vue'],resolve),\n        meta:{auth:true,keepAlive: true},\n        name:'NewCase'\n    },//推荐\n    {\n        path:'/Recommend',\n        component: resolve => require(['../components/mainTem/Recommend.vue'],resolve),\n        meta:{auth:true,keepAlive: true},\n        name:'Recommend'\n    },//个人中心\n    {\n        path:'/User',\n        component: resolve => require(['../components/mainTem/User.vue'],resolve),\n        meta:{auth:true,keepAlive: true},\n        name:'User'\n    },//筛选\n    {\n        path:'/Filtrate',\n        component: resolve => require(['../components/mainTem/Filtrate.vue'],resolve),\n        meta:{auth:true,keepAlive: false},\n        name:'Filtrate'\n    },\n    {//详情\n        path:'/Detail',\n        component: resolve => require(['../components/mainTem/Detail.vue'],resolve),\n        meta:{auth:true,keepAlive: false},\n        name:'Detail'\n    }\n]\n\n```\n\n### 监听\n\n我用的是localStorage储存的用户token值。\n业务逻辑：用户没有localStorage说明是第一次登录，则直接跳到登录页面，在登录页面储存token值，存在localStorage，用户关闭页面后，在24小时内，再次打开页面直接进入主页面，通过localStorage去判断当前token是否有效，如果已失效，则提示登录已超时，重新跳到登录页面。\n\n#### meta\n只有在路由中设置了meta auto属性为true的才判断，以上路由全部由设置\n#### o\nto为向后走的路由对象，包括路由的完整信息\n#### from\nfrom为从哪跳来的路由对象\n#### next()\nnext()控制路由向下走，重新定义路由跳转的路由next('路由路径)\n\n```js\n/** 验证用户是否登录 **/\nrouter.beforeEach((to,from,next) => {\n    if(to.matched.some( m => m.meta.auth)) {\n        // console.log(\"先判断是否登录\");\n        if(to.name=='Login'){\n            next();\n        }else{\n          if(localStorage.getItem('token')){\n          \n          //访问服务器缓存数据，判断当前token是否失效\n            Vue.http.get(\"http:xxxx/Login/UserIsLogin?token=\"+localStorage.getItem('token')+\"&url=\"+to.name,{withCredentials: true}).then(response => response.json()).then(num => {\n                    // console.log('是否登录',num);\n                    if(num.code==1001){\n                        next();\n                    }else{\n                        alert('您的token已超时，请重新登录');\n                        next('/Login');\n                    }\n            })\n          }else{\n            next('/Login');\n          }\n\n        }\n  　} else {\n        console.log(\"请先登录\");\n        next()\n    }\n})\n```\n\n"
  },
  {
    title: 'vue.js搭建个人博客',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "## 为何选择vue.js搭建博客\n\n为什么会选择使用vue.js框架搭建博客呢？原因有多个。作为前后端分离的多数据绑定项目，首选的就是mvc 以及mvvm等框架，也就是主流的react 和vue；在使用vue.js框架快速完成美食网站后，更加离不开这个框架了，简单方便，易于管理和后期的维护。\n\n## 个人博客框架\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-7183a8818f58081d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>如图所示，页面整体可分为几大主模块，有首页、分类、实验室、赞赏、伙伴、留言板、关于、登录注册、用户个人中心，这些主模块通过路由跳转切换；然后还有几个公共模块，如头部和尾部，以及其他的一些公用模块，这些子模块嵌套在主模块中，用于公用样式和公用功能的实现。\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-9e8ec0e2e62fb67e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-1829da6fe062f5c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>项目基于node.js npm 安装vue-cli 脚手架后 的目录结构，如下图，根据项目的需求选择性的安装依赖和插件\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-6fad2874c5b9aa5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>搭建博客所安装的插件和依赖，如下图，我使用了 element-ui组件来开发样式，还有vue-resource和vue-router 以及css-loader等样式加载依赖，安装成功后，在webpack.config.js上写上相应的配置\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-bdd8be9e8ce9af25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>得在上图中的routes完成主路由模块的配置，并且export出来，这里需要注意的是，可以通过component: resolve 来设置懒加载，对于带宽为1M的服务器来说，这点非常重要，不然打开页面需要好几分钟，还需要在webpack.config.js中注释掉 devtool: '#eval-source-map'，这个是项目webpack打包的时候设置的参数，使用webpack -p 这个命令打包，即为压缩打包，打包的文件更小，除去不需要的注释\n\n>接着是入口文件文件的配置，根据自己的需求，引入对应的模块和路由等文件\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-f496b0c7092b8644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 运行项目\n\n使用命令窗口，cd到当前目录，使用npm run dev ，就可以打开运行项目，编辑项目保存的同时，页面会自动更新，即为实时监控。\n\n## 模块化开发\n之所以使用vue.js来开发博客项目，其中看中的一点就是模块化开发，就以打开页面的首页为例，如上面的结构介绍图，我分别使用了头部、尾部、右侧、文章列表这四个子模块组成，就如下图所示\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-4dea9d029af5b1eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n子模块的结构和主模块一样，如果子模块中还需嵌套子模块，同上面一样\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-c0864c1d1caf38a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>按照上面的步骤根据自己的需求添加自己的模块，整个博客网站就搭建完成啦，是不是很简单呢！如果需要了解vue.js具体的api 和element-ui组件的用法，可以访问官方网站，都有详细的说明哦！\n\n博客地址： http://mangoya.cn\n需要看详细文档的，这里有github 地址 https://github.com/Aimee1608"
  },
  {
    title: 'vue.js项目 评论留言模块支持表情包',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: '# vue.js项目 评论留言模块支持表情包\n\n> **需通过后台处理表情包：**数据库存储字段，前端直接处理转换成表情。\n\n- **页面结构搭建：如图，页面布好文本域框和表情列表**\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-286f1b8bf0e21a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-0bbaaa509219992e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- **根据表情包的内容，转化成对应的描述和路径**\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-29dddfd3b0b1dcf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- **文本域框中展示选中的表情包内容**\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-7f7590ee06dcb9fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-7217e7fa41782417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- **后台数据传入时，正则匹配替换相应的内容为表情**\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-d6ad12c26825a203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-0f9ed22a8c32e6bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n> **注：**如果需要不以图片的形式存本地，方法同上，把可以前端可以识别的表情 直接替换到图片路径，从服务器获取来的表情描述正则匹配替换时，直接替换成字符串，不需要以图片的形式加载。如果需要在文本域展示，需要在点击表情包，给文本域赋值的时候，文本域里的内容追加替换成表情包，另存一份内容为表情包对用的描述追加的文本域内容，存后台数据库的时候，存后面这一内容，而非文本域展示的内容。\n'
  },
  {
    title: 'webpack 压缩打包 vue.js  项目 懒加载快速加载页面',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "> 之前直接使用webpack --color --progress 命令打包vue.js项目，打包出来的项目，只有一个build.js文件，只是一个普通的小网站项目，却有2.9MB，放在贷款为2兆的阿里云服务器上，首次加载硬是要了四五分钟，非常的慢了。后来查询各种办法，最终解决了问题，如下：\n\n\t\n\n- **使用懒加载引用路由模块**\n\n 原始的import [路由名] from  [路由路径] 方式 改为 component :resolve => require([路由路径]，resolve)，改为懒加载的引入方法后，页面首次加载会变快，dist目录里面会生成和路由模块对应的序列.bulid.js 文件，当加载默认的模块时，页面异步加载对应模块的js文件。\n\n```js\nconst routes =[\n    {\n      path: '/',\n      name:'Home',\n      component: resolve => require(['./templet/mainTem/Home.vue'],resolve)\n    },//默认首页\n    {\n      path:'/Foodlist',\n      name:'Foodlist',\n      component: resolve => require(['./templet/mainTem/Foodlist.vue'],resolve)\n    },//菜谱\n    {\n      path:'/Select',\n      name:'Select',\n      component: resolve => require(['./templet/mainTem/Select.vue'],resolve)\n    },//分类\n    {\n      path:'/Hotnews',\n      name:'Hotnews',\n      component: resolve => require(['./templet/mainTem/Hotnews.vue'],resolve)\n    },//热门文章\n    {\n      path:'/Itemlist',\n      name:'Itemlist',\n      component: resolve => require(['./templet/mainTem/Itemlist.vue'],resolve)\n    },//菜谱详情\n    {\n      path:'/Suggestion',\n      name:'Suggestion',\n      component: resolve => require(['./templet/mainTem/Suggestion.vue'],resolve)\n    },//意见反馈\n    {\n      path:'/About',\n      name:'About',\n      component: resolve => require(['./templet/mainTem/About.vue'],resolve)\n    },//关于\n    {\n      path:'/FriendsLink',\n      name:'FriendsLink',\n      component: resolve => require(['./templet/mainTem/FriendsLink.vue'],resolve)\n    },//友情链接\n    {\n      path:'/Advertising',\n      name:'Advertising',\n      component: resolve => require(['./templet/mainTem/Advertising.vue'],resolve)\n    }//广告合作\n]\n\nexport default routes\n```\n如图：\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-27da422479363c0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- **设置webpack.config.js**\n\t\t\t\t\n注释掉devtool: '#eval-source-map'，避免多余的console.log  或者其他的debug 等代码，压缩打包文件的大小。\n```js\nvar path = require('path')\nvar webpack = require('webpack')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    publicPath: 'dist/',\n    filename: 'build.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {\n          loaders: {\n          }\n          // other vue-loader options go here\n        }\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: 'file-loader',\n        options: {\n          name: '[name].[ext]?[hash]'\n        }\n     },\n     {\n\n        test: /\\.css$/,\n        loader: \"style-loader!css-loader\",\n        // options: {\n        //     name: '[name].[ext]?[hash]'\n        // }\n    },\n    {\n\n        test: /\\.less$/,\n        loader: \"style-loader!css-loader!less-loader\",\n\n    },\n    {\n        test: /\\.(png|jpg|gif|svg|woff|ttf|eot|woff2)$/,\n        loader: 'file-loader',\n        options: {\n            name: '[name].[ext]?[hash]'\n        }\n    },\n    ]\n  },\n  resolve: {\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js'\n    }\n  },\n  devServer: {\n    historyApiFallback: true,\n    noInfo: true\n  },\n  performance: {\n    hints: false\n  },\n  // devtool: '#eval-source-map'//注释掉\n}\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports.devtool = '#source-map'\n  // http://vue-loader.vuejs.org/en/workflow/production.html\n  module.exports.plugins = (module.exports.plugins || []).concat([\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new webpack.optimize.UglifyJsPlugin({\n      sourceMap: true,\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.LoaderOptionsPlugin({\n      minimize: true\n    })\n  ])\n}\n\n```\n- **webpack——devtool里的7种SourceMap模式**\n|  模式            | 解释 | \n| ------------------|-------------| \n| eval \t\t| 每个module会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL. | \n| source-map | 生成一个SourceMap文件. | \n| hidden-source-map | 和 source-map 一样，但不会在 bundle 末尾追加注释. | \n|  inline-source-map | 生成一个 DataUrl 形式的 SourceMap 文件.   |\n|  eval-source-map |  每个module会通过eval()来执行，并且生成一个DataUrl形式的SourceMap.  |\n|  cheap-source-map |  生成一个没有列信息（column-mappings）的SourceMaps文件，不包含loader的 sourcemap（譬如 babel 的 sourcemap）  |\n|  cheap-module-source-map |  生成一个没有列信息（column-mappings）的SourceMaps文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。  |\n\n\n这么多模式用哪个好？\n开发环境推荐：\n\ncheap-module-eval-source-map\n\n生产环境推荐：\n\ncheap-module-source-map\n\n原因如下：\n\n 1. 使用 cheap 模式可以大幅提高 souremap 生成的效率。大部分情况我们调试并不关心列信息，而且就算 sourcemap 没有列，有些浏览器引擎（例如 v8） 也会给出列信息。\n \n 2. 使用 eval 方式可大幅提高持续构建效率。官方文档提供的速度对比表格可以看到 eval 模式的编译速度很快。\n \n 3. 使用 module 可支持 babel 这种预编译工具（在 webpack 里做为 loader 使用）。\n \n 4. 使用 eval-source-map 模式可以减少网络请求。这种模式开启 DataUrl 本身包含完整 sourcemap 信息，并不需要像 sourceURL 那样，浏览器需要发送一个完整请求去获取 sourcemap 文件，这会略微提高点效率。而生产环境中则不宜用 eval，这样会让文件变得极大。\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-df66a50a39f4e68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n"
  },
  // ====上面vue ====
  // node
  {
    title: '搭建node 简易服务',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11cb8d9fd118d82f2f10'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "### 安装node\n\n1、[Node官网](https://nodejs.org/zh-cn/)下载pkg安装包，点击安装即可，安装包包含nodejs和npm(node package manager)\n2、安装完成后，在命令终端输入\n\n```\ncurl http://npmjs.org/install.sh | sh\n```\n3、这个npm.js实际上是Node.js的套件管理工具，执行完成之后我们继续执行命令，更新npm：\n\n```\nsudo npm update npm -g\n```\n4、查看npm是否安装成功\n\n```\nnpm -v\n```\n\n### 创建node  服务\n创建node  服务和web 端通信需要用到http、https\n如果访问文件需要用到fs\n#### 首先创建一个服务\n1、新建一个文件server.js\n2、引入对应所需的依赖\n```js\nvar http=require('http');\nvar https = require('https')\nvar fs = require('fs');\n```\n3、创建http 服务\n\n```js\nconst server = http.createServer((req, res) => {\n\t// 这里可以设置header信息, 如跨域等信息\n}).listen(8090)\n```\n4、启动服务\n> 以上内容即可启动服务，可以通过node 的命令启动服务，默认域名是http://127.0.0.1:8090\n即可访问node 服务，可以对创建的服务添加一些监听\n\n####  对创建的服务监听request请求\nrequest 监听有两个参数，req 请求 和 res 响应\n添加监听的方法， 如文件的请求，方法接口的请求\n```js\nconst requestHandle = (req, res) => {\n\t// 设置一些 请求处理的方法\n\tif (url === '/index') { // 文件的请求\n\t    res.writeHead(200, {\n\t      'Content-Type': 'text/html'\n\t    })\n\t    fs.readFile('index.html', 'utf8', function (err, data) {\n\t      if (err) throw err\n\t      res.end(data)\n\t    })\n\t } else if (url === '/api') { // 接口请求\n\t    req.on('data', function (pamas) {\n\t      console.log('8888888')\n\t      // 在此做一些数据的处理\n\t    })\n\t    req.on('end', () => {\n\t    \t// 请求结束\n\t    })\n\t} else { // 404 请求\n\t    res.write('404')\n\t    res.end()\n   }\n}\n```\n添加监听\n```js\nserver.on('request', requestHandle)\n```\nconsole.log 的内容均在服务终端上会展示出来\n\n#### node服务请求其他服务\n以钉钉报警为例，由于前端不支持直接请求钉钉报警接口，需要通过服务来转发请求，便有了如下例子\n\n```js\nconst dingdingHandle = (str, callback) => {\n// 钉钉报警传参\n  const postData = {\n    msgtype: \"text\",\n    text: {\n      content: str\n    },\n    \"at\": {\n      \"atMobiles\": [\n          \"155********\"\n      ], \n      \"isAtAll\": false\n    }\n  };\n\n  const options = {\n    hostname: 'oapi.dingtalk.com',\n    path: '/robot/send?access_token=d529ae67dcc82157032c3c84bad0c450a2329692adca0e00000efcbddf2898',\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json;charset=UTF-8',\n    }\n  };\n\n  const req = https.request(options, (res) => {\n    console.log(`状态码: ${res.statusCode}`);\n    console.log(`响应头: ${JSON.stringify(res.headers)}`);\n    res.setEncoding('utf8');\n    res.on('data', (chunk) => {\n      console.log(`响应主体: ${chunk}`);\n      callback(chunk)\n    });\n    res.on('end', () => {\n      console.log('响应中已无数据。');\n    });\n  });\n\n  req.on('error', (e) => {\n    console.error(`请求遇到问题: ${e.message}`);\n  });\n\n  // 写入数据到请求主体\n  req.write(JSON.stringify(postData));\n  req.end();\n}\n```\n\n这个方法在接收到对应的请求时调用\n在服务端request 监听的回调中对应的接口中调用\n\n```js\n...\n } else if (url === '/api') { // 接口请求\n   req.on('data', function (params) {\n      console.log('8888888')\n      // 请求钉钉报警接口，并将响应返回的参数推到前端页面的请求中\n      dingdingHandle(params.toString, (data) => {\n      \tres.end(data)\n      })\n    })\n    req.on('end', () => {\n    \t// 请求结束\n    })\n} else { // 404 请求\n...\n```\n### 前端页面接口请求\n前端页面请求，业务场景是页面报错时监听\n\n```js\n window.onerror = function (msg, url, line, column, error) {\n      let data = {\n        msg: msg, \n        url: url, \n        line: line, \n        col: column\n      }\n      console.log(data, '--------------');\n      let xhr = new XMLHttpRequest()\n      // xhr.withCredentials = true\n      xhr.open('POST', 'http://127.0.0.1:8090/api', true)\n      xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n      xhr.send(JSON.stringify(data))\n      xhr.onreadystatechange = function () {\n        xhr.readyState === 4 && xhr.status === 200 && console.log('ok', xhr.responseText)\n      }\n    }\n```\n### 跨域\n当前前端页面的服务为http://127.0.0.1:8080/，和node  服务存在跨域，此时需要在创建服务的时候，添加header 设置\n\n```js\nconst server = http.createServer(function(req,res) {\n  res.setHeader('Access-Control-Allow-Origin', '*')\n  res.setHeader('Access-Control-Allow-Oring', 'http://127.0.0.1:8080/')\n  res.setHeader('Access-Control-Allow-Credentials', true)\n}).listen(8090);\n```\n\n>注意：\n如果是vue  项目中的axios, 需要手动设置header 以及强转化传输的数据\n\n```js\nimport axios from 'axios'\nimport qs from 'qs'\naxios({\n    method: 'post',\n    url: 'http://127.0.0.1:8090/api',\n    data: errorData,\n    withCredentials: false,\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    transformRequest: [sdata => { // 强转数据格式\n      console.log(sdata, qs.stringify(sdata))\n      return qs.stringify(sdata)\n    }]\n  }).then(res => {\n    console.log('res=>', res) \n  })\n```\n\n"
  },
  // 小技巧
  {
    title: 'mac更新后git不可用',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "### 更新后报错\n错误提示如下：\n```javascript\ndyld: Library not loaded: @rpath/libswiftCore.dylib\n  Referenced from: /Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild\n  Reason: image not found\ngit: error: unable to locate xcodebuild, please make sure the path to the Xcode folder is set correctly!\ngit: error: You can set the path to the Xcode folder using /usr/bin/xcode-select -switch\n```\n\n### 查找解决方案\n网上查到输入下面的命令\n```javascript\nsudo xcode-select --switch /Library/Developer/CommandLineTools/\n```\n仍然报错：\n\n```javascript\nxcode-select: error: invalid developer directory '/Library/Developer/CommandLineTools/'\n```\n安装xcode-select\n\n```javascript\nxcode-select --install\n```\n根据提示的弹框安装xcode-select\n再次执行如下命令 \n\n```javascript\nsudo xcode-select --switch /Library/Developer/CommandLineTools/\n```\n执行完不报错，ok "
  },
  {
    title: 'zsh: command not found:nodemon',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: '### nodemon 安装 mac提示 zsh: command not found: nodemon\n\n#### 安装nodemon\nnpm install -g nodemon \n提示安装成功\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/13238271-d5ccc881e614ce6a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 查看版本\n却提示zsh: command not found: nodemon\n\n主要是原因是环境变量没有设置对的原因\n根据安装的提示路径：/usr/local/Cellar/node/11.13.0/bin/nodemon \n可以进入到此目录 /usr/local/Cellar/node/11.13.0/bin 能看到启动文件\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/13238271-20a333c178e6d774?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开设置环境变量的文档 open ~/.zshrc\n在底部添加环境变量\nexport PATH="/usr/local/Cellar/node/11.13.0/bin:$PATH"\n保存后，执行source ~/.zshrc使刚修改的生效\n改完后发现生效了 之前安装的不生效的也成功了\n\n#### 补充\n可以通过 echo $PATH 查看环境变量，判断是否添加成功，或者安装全局的路径是否添加到了全局环境变量中\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/13238271-310f9bdb5c297796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)'
  },
  {
    title: '手动控制console.log开关',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "手机端查看console.log \n网上有很多插件，在页面中引用就可以\n>小技巧：当页面url 有eruda=true参数时，开启\n```js\n(function () {\n   var src = 'https://cdn.bootcss.com/eruda/1.5.4/eruda.min.js'\n   if (!/eruda=true/.test(window.location) && localStorage.getItem('active-eruda') != 'true') return\n   document.write('<scr' + 'ipt src=\"' + src + '\"></scr' + 'ipt>')\n   document.write('<scr' + 'ipt>eruda.init();</scr' + 'ipt>')\n })()\n```\n\npc 页面不想他人看见console.log 消息，但是必要时候又需要打开调试\n\n>小技巧：当页面有console=true参数时，才能看到consle.log 的内容\n```js\nif (!/console=true/.test(window.location)) {\n  console.log = () => {}\n}\n```\n"
  },
  {
    title: 'iphone x/xr/xs/xs max 微信input输入框和吸底兼容问题',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: '### 问题\n1、底部吸底兼容问题，iphone x/xs max/xr 会有黑条\n2、input 输入聚焦时候，input 框会下滑道下面，虚拟键盘会挡住input, 无法看到输入的内容\n3、input 输入框失去焦点时，输入框会停留到当前，需要手动去往下滑动，才能回到底部\n\n\n### 解决\n#### 样式兼容\nhead 设置shrink-to-fit=no  viewport-fit=cover\n\n```html\n<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0, shrink-to-fit=no, viewport-fit=cover" name="viewport" >\n   \n```\n\n```css\n/** x/xs **/\n@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3){\n    .Chat-foot{\n      padding-bottom: constant(safe-area-inset-bottom);\n      padding-bottom: env(safe-area-inset-bottom);\n    }\n}\n/** xr **/\n@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2){\n    .Chat-foot{\n      padding-bottom: constant(safe-area-inset-bottom);\n      padding-bottom: env(safe-area-inset-bottom);\n    }\n}\n/** xs max **/\n@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3){\n    .Chat-foot{\n      padding-bottom: constant(safe-area-inset-bottom);\n      padding-bottom: env(safe-area-inset-bottom);\n    }\n}\n```\n\n另外对于其他top /right/left 的设置有\n\n```css\n padding-top: constant(safe-area-inset-top);   //为导航栏+状态栏的高度 88px            \n padding-left: constant(safe-area-inset-left);   //如果未竖屏时为0                \n padding-right: constant(safe-area-inset-right); //如果未竖屏时为0                \n padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px       \n\n```\n\n#### input 输入框位置\n输入时 focus 监听方法里面\n\n```js\nvar timer = setTimeout(() => {\n   window.scroll(0, document.body.scrollHeight)\n   clearTimeout(timer)\n   timer = null\n }, 100)\n```\n完成输入失去焦点滚动到想要的位置\n\n```js\n window.scroll(0, 0)\n```\n'
  },
  {
    title: 'canvas 画圆角矩形头像合成图片',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "#### 生成canvas\n##### 获取屏幕比率\n有的手机屏幕实际分辨率的像素比页面过去的尺寸像素要大，一遍是一倍或者两倍\n```js\nvar getPixelRatio = function(context) {\n  var backingStore = context.backingStorePixelRatio ||\n      context.webkitBackingStorePixelRatio ||\n      context.mozBackingStorePixelRatio ||\n      context.msBackingStorePixelRatio ||\n      context.oBackingStorePixelRatio ||\n      context.backingStorePixelRatio || 1;\n  return (window.devicePixelRatio || 1) / backingStore;\n};\n```\n##### 初始化canvas\n```js\nvar canvas = document.createElement('canvas')//画布\nvar ctx = canvas.getContext(\"2d\"); \nvar ratio = getPixelRatio(ctx); // 获取屏幕比率\ncanvas.width = 750*ratio; // 设置生成图片容器的宽高\ncanvas.height = 1335*ratio; \nctx.clearRect(0,0,canvas.width,canvas.height); // 设置背景颜色\nctx.fillStyle = '#000000';\nctx.fillRect(0,0,canvas.width, canvas.height);\n```\n\n ##### 画圆形头像方法\n```js\nfunction drawRound (ctx,r,x,y,img) {\n\tctx.save() // 保存之前的\n\tvar r = r // 半径*屏幕分辨率比例\n\tvar d = 2*r // 直径\n\tvar cx = x + r // 圆弧坐标x\n\tvar cy = y + r // 圆弧坐标 y\n\tctx.arc(cx, cy, r ,0, 2*Math.PI)\n\tctx.clip() // 裁剪\n\tctx.drawImage(img, x, y, d, d) // 画头像\n\tctx.restore() // 返回上一状态\n}\n```\n##### 画圆角矩形头像方法\n```js\nfunction drawRoundRect (ctx,r,x,y,w,h,img) {\n\tctx.save()\n\tif (w < 2 * r) r = w / 2\n    if (h < 2 * r) r = h / 2\n    ctx.beginPath()\n    ctx.moveTo(x+r, y)\n    ctx.arcTo(x+w, y, x+w, y+h, r)\n    ctx.arcTo(x+w, y+h, x, y+h, r)\n    ctx.arcTo(x, y+h, x, y, r)\n    ctx.arcTo(x, y, x+w, y, r)\n    ctx.closePath();\n    ctx.clip()\n    ctx.drawImage(img, x, y, w, h)\n\tctx.restore() // 返回上一状态\n}\n```\n##### 画背景图\n\n```js\nvar bg = new Image()\nbg.crossOrigin = \"*\"; // 设置图片跨域问题\nbg.src = 'img/bg.jpg'\nbg.onload = function() { \n\tctx.drawImage(bg, 0, 0, bg.width, bg.height, 0, 0, canvas.width, canvas.height);\n\t// 画完背景图后，画头像\n\tvar head = new Image()\n    head.crossOrigin = \"*\"\n    head.src = 'img/head.jpg'\n    head.onload = function() {\n    \t//画头像,这里画矩形图\n    \tvar r = 10*ratio\n        var x = 325*ratio\n        var y = 500*ratio\n        var w = 100*ratio\n        var h = 100*ratio\n        drawRoundRect(ctx,r,x,y,w,h,head)\n    }\n}\n```\n正方形圆角，如下图\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-7381d4837be452d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n圆形头像，如下图\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-19f58de6ccb19d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n##### 导出生成头像链接\n导出的数据为base64的图片链接，可以赋值到需要展示的图片上，这样就能实现图片合成的效果了\n```js\n var imgData = canvas.toDataURL()\n```\n\n完整代码如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n  <style>\n  \tbody{\n  \t\tmargin: 0;\n  \t\tpadding: 0;\n  \t}\n  \t.container{\n  \t\twidth: 375px;\n  \t\theight: 667px;\n  \t}\n  \t.container img{\n  \t\twidth: 100%;\n  \t\theight: 100%;\n  \t}\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n  \t<img id=\"result\" src=\"\" alt=\"\">\n  </div>\n  <script src=\"https://cdn.bootcss.com/jquery/3.3.0/jquery.min.js\"></script>\n  <script>\n  \t$(function(){\n  \t\tvar getPixelRatio = function(context) {\n\t\t  var backingStore = context.backingStorePixelRatio ||\n\t\t      context.webkitBackingStorePixelRatio ||\n\t\t      context.mozBackingStorePixelRatio ||\n\t\t      context.msBackingStorePixelRatio ||\n\t\t      context.oBackingStorePixelRatio ||\n\t\t      context.backingStorePixelRatio || 1;\n\t\t  return (window.devicePixelRatio || 1) / backingStore;\n\t\t}\n\t\tvar canvas = document.createElement('canvas')//画布\n\t\tvar ctx = canvas.getContext(\"2d\"); \n\t\tvar ratio = getPixelRatio(ctx); // 获取屏幕比率\n\t\tcanvas.width = 750*ratio; // 设置生成图片容器的宽高\n\t\tcanvas.height = 1335*ratio; \n\t\tctx.clearRect(0,0,canvas.width,canvas.height); // 设置背景颜色\n\t\tctx.fillStyle = '#000000';\n\t\tctx.fillRect(0,0,canvas.width, canvas.height);\n\n\t\tfunction drawRound (ctx,r,x,y,img) {\n\t\t\tctx.save() // 保存之前的\n\t\t\tvar r = r // 半径*屏幕分辨率比例\n\t\t\tvar d = 2*r // 直径\n\t\t\tvar cx = x + r // 圆弧坐标x\n\t\t\tvar cy = y + r // 圆弧坐标 y\n\t\t\tctx.arc(cx, cy, r ,0, 2*Math.PI)\n\t\t\tctx.clip() // 裁剪\n\t\t\tctx.drawImage(img, x, y, d, d) // 画头像\n\t\t\tctx.restore() // 返回上一状态\n\t\t}\n\t\tfunction drawRoundRect (ctx,r,x,y,w,h,img) {\n\t\t\tctx.save()\n\t\t\tif (w < 2 * r) r = w / 2\n\t\t    if (h < 2 * r) r = h / 2\n\t\t    ctx.beginPath()\n\t\t    ctx.moveTo(x+r, y)\n\t\t    ctx.arcTo(x+w, y, x+w, y+h, r)\n\t\t    ctx.arcTo(x+w, y+h, x, y+h, r)\n\t\t    ctx.arcTo(x, y+h, x, y, r)\n\t\t    ctx.arcTo(x, y, x+w, y, r)\n\t\t    ctx.closePath();\n\t\t    ctx.clip()\n\t\t    ctx.drawImage(img, x, y, w, h)\n\t\t\tctx.restore() // 返回上一状态\n\t\t}\n\n\t\tvar bg = new Image()\n\t\tbg.crossOrigin = \"*\"; // 设置图片跨域问题\n\t\tbg.src = 'img/J-bg.jpg'\n\t\tbg.onload = function() { \n\t\t\tctx.drawImage(bg, 0, 0, bg.width, bg.height, 0, 0, canvas.width, canvas.height);\n\t\t\t// 画完背景图后，画头像\n\t\t\tvar head = new Image()\n\t\t    head.crossOrigin = \"*\"\n\t\t    head.src = 'img/head.jpg'\n\t\t    head.onload = function() {\n\t\t    \t//画头像,这里画矩形图\n\t\t    \tvar r = 100*ratio\n\t\t        var x = 325*ratio\n\t\t        var y = 500*ratio\n\t\t        var w = 100*ratio\n\t\t        var h = 100*ratio\n\t\t        drawRoundRect(ctx,r,x,y,w,h,head)\n\t\t        var imgData = canvas.toDataURL()\n\t\t        $('#result').attr('src', imgData)\n\t\t    }\n\t\t}\n  \t})\n  </script>\n</body>\n</html>\n\n```\n"
  },
  {
    title: 'mac使用命令终端连接linux服务器',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: '\n打开Mac终端，切换到root权限下\n\n    切换root权限： sudo -i  \n\n通过ssh命令连接linux服务器\n\n    ssh root@127.0.0.1\n\n    root是账户名，@后面的是连接的ip地址\n\n然后根据提示输入密码即可成功\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-7f22b3c9378e474f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n'
  },
  {
    title: 'js获取浏览器类别',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "完整版获取浏览器类别：特别注意的是ie 11的判断和ie11之前的都不一样\n```js\nfunction getBrowser() {\n    var userAgent = navigator.userAgent; // 取得浏览器的userAgent字符串\n    var isOpera = userAgent.indexOf(\"Opera\") > -1; // 判断是否Opera浏览器\n    var isIE = userAgent.indexOf(\"compatible\") > -1\n            && userAgent.indexOf(\"MSIE\") > -1 && !isOpera; // 判断是否IE浏览器\n    var isEdge = userAgent.indexOf(\"Edge\") > -1; // 判断是否IE的Edge浏览器\n    var isIE11 = userAgent.indexOf('Trident') > -1 \n    \t\t&& userAgent.indexOf(\"rv:11.0\") > -1; // 判断是否IE<11浏览器\n    var isFF = userAgent.indexOf(\"Firefox\") > -1; // 判断是否Firefox浏览器\n    var isSafari = userAgent.indexOf(\"Safari\") > -1\n            && userAgent.indexOf(\"Chrome\") == -1; // 判断是否Safari浏览器\n    var isChrome = userAgent.indexOf(\"Chrome\") > -1\n            && userAgent.indexOf(\"Safari\") > -1; // 判断Chrome浏览器\n    if (isIE) {\n        var reIE = new RegExp(\"MSIE (\\\\d+\\\\.\\\\d+);\");\n        reIE.test(userAgent);\n        var fIEVersion = parseFloat(RegExp[\"$1\"]);\n        if (fIEVersion == 7) {\n            return \"IE7\";\n        } else if (fIEVersion == 8) {\n            return \"IE8\";\n        } else if (fIEVersion == 9) {\n            return \"IE9\";\n        } else if (fIEVersion == 10) {\n            return \"IE10\";\n        } else if (fIEVersion == 11) {\n            return \"IE11\";\n        } else {\n            return \"0\";\n        }//IE版本过低\n        return \"IE\";\n    }\n    if (isOpera) {\n        return \"Opera\";\n    }\n    if (isEdge) {\n        return \"Edge\";\n    }\n    if (isFF) {\n        return \"FF\";\n    }\n    if (isSafari) {\n        return \"Safari\";\n    }\n    if (isChrome) {\n        return \"Chrome\";\n    }\n}\n```\n"
  },
  {
    title: '滚动条设置 兼容chrome和ie',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: '## 滚动条设置\n\nchrome css 样式设置\n\n```css\n/* 滚动条样式 .wrap为滚动盒子的class*/\n/* chrome */ \n.wrap::-webkit-scrollbar {/*滚动条整体样式*/\n    width: 4px;     /*高宽分别对应横竖滚动条的尺寸*/\n    height: 1px;\n}\n.wrap::-webkit-scrollbar-thumb {/*滚动条里面小方块*/\n    border-radius: 4px;\n    background: #A1A1A1;\n}\n.wrap::-webkit-scrollbar-track {/*滚动条里面轨道*/\n    border-radius: 4px;\n    background: #F9F9F9;\n    margin: 30px 0;\n}\n```\nie 浏览器样式\n\n```css\n/* ie */\n.wrap{\n    scrollbar-arrow-color: #A1A1A1; /**//*三角箭头的颜色*/ \t\t\n    scrollbar-face-color: #A1A1A1; /**//*立体滚动条的颜色*/ \t\t\n    scrollbar-3dlight-color: transparent; /**//*立体滚动条亮边的颜色*/ \t\t\n    scrollbar-highlight-color: transparent; /**//*滚动条空白部分的颜色*/ \t\t\n    scrollbar-shadow-color: transparent; /**//*立体滚动条阴影的颜色*/ \t\t\n    scrollbar-darkshadow-color: transparent; /**//*立体滚动条强阴影的颜色*/ \t\t\n    scrollbar-track-color: #F9F9F9; /**//*立体滚动条背景颜色*/ \t\t\n    scrollbar-base-color: transparent; /**//*滚动条的基本颜色*/\n}\n```\n火狐浏览器目前没有找到兼容的样式'
  },
  {
    title: 'iframe   后退 浏览器history 问题',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11e18d9fd118d82f2f14'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "## 问题\n浏览器机制的原因，在iframe导航变化后手动点击浏览器的后退按钮也依然只是后退iframe中的导航\n\n只想让父页面后退，并不想让iframe 后退，但在改变了iframe 的src 后就达不到这样的效果\n\n## 解决\n\n不要修改iframe.src，而是删除旧iframe元素，新建一个iframe元素并替换它，这样不会产生history。\n直接createElement，替换原来的iframe。\n\n## 案例\n### 父页面 iframe.html\n\n```\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge, chrome=1\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <title></title>\n    </head>\n    <body>\n        <h1>父页面</h1>\n        <button id=\"openBtn\">打开iframe</button>\n        <div id=\"h5SourceShow\" style=\"display:none\">\n          <iframe id=\"iframe\" src=\"\" width=\"300\" height=\"400\"></iframe>\n        </div>\n    </body>\n    <script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"></script>\n    <script>\n    $(function(){\n      $('#openBtn').click(function(){\n        $('#iframe').attr('src', 'iframe-demo.html')\n          $('#h5SourceShow').css('display','block')\n      })\n      window.addEventListener('message', function (e) {\n          console.log(e);\n          if (e.data.type == 'coursewareH5Close') {\n              coursewareH5Close();\n          }else{\n\n          }\n      }, false);\n    })\n  function coursewareH5Close(){\n     var iframe = '<iframe id=\"iframe\" src=\"\" width=\"300\" height=\"400\"></iframe>'\n     $('#iframe').remove()\n      $('#h5SourceShow').css('display','none').html(iframe)\n  }\n    </script>\n</html>\n```\n\n### 嵌套的子页面 iframe-demo.html\n\n```\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge, chrome=1\">\n        <meta name=\"renderer\" content=\"webkit\">\n        <title></title>\n    </head>\n    <body style=\"background:pink\">\n        <h2>子页面</h2>\n        <button id=\"closeBtn\">关闭iframe</button>\n    </body>\n    <script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"></script>\n    <script>\n    $(function(){\n      $('#closeBtn').click(function(){\n        var e = {\n                type: \"coursewareH5Close\"\n            };\n            window.parent.postMessage(e, \"*\"),\n            console.log(\"postMessage:\", e)\n      })\n    })\n    </script>\n</html>\n```\n\n**通过打开按钮打开 iframe，然后使用iframe 里面的关闭按钮，给父页面传递message，关闭当前的iframe，直接移除当前的iframe，创建新的iframe。**"
  },
  {
    title: 'H5移动端横竖屏切换监听  副作用——手机整屏状态下安卓机input 问题',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "## H5移动端横竖屏切换监听\n上一次说过了 H5移动端横竖屏切换监听的写法。\n\n横竖屏监听代码如下，这里就不做详细说明了。[完整说明](http://blog.csdn.net/aimee1608/article/details/78100197)\n```\n$(function(){//监听横竖屏旋转，ios 和 Android 写法不一样  \n    onResize();  \n    if (!!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)) {  \n        window.addEventListener(\"onorientationchange\" in window ? \"orientationchange\" : \"resize\", onResize, false);  \n    }else{  \n        window.addEventListener( \"resize\", onResize, false);  \n    }  \n});  \n  \nfunction  onResize() {  \n  \n    if(Utils.isPortrait()){  \n        if(!!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)){  \n  \n            var timer = setTimeout(function(){  \n                portrait();//竖屏时执行的函数  \n  \n                clearTimeout(timer);  \n            },100);  \n        }else{  \n            portrait();  \n        }  \n    } else {  \n        if(!!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)){  \n            var timer = setTimeout(function(){  \n                landscape();//横屏时执行的函数  \n                clearTimeout(timer);  \n            },100);  \n        }else{  \n            landscape();  \n        }  \n    }  \n}  \n```\n\n现在说说在有横竖屏监听时，同时还有input  输入框。\n页面在输入时 容易的问题，如图\n##问题\n\n### 图1   ios 系统输入时\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-1c81dbefcaca39f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 图2 正常横屏时的提示\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-3c25753e415c08f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 图3 Android 输入时显示的页面\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-809d81f57d93fef6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n如图所示，android 系统点击input 输入框时，整个输入框是占据屏幕空间的，因此页面会向上压缩，导致了监听的横竖屏的结果为横屏状态，出现了页面提示，导致无法输入，影响页面效果。\n\n## 解决方法\n\n在input 聚焦时，对于非ios 系统的设备，移除当前页面的横竖屏监听。可能还有其他更好的方法，后续有待研究...\n```\n\n$('input').focus(function(){\n\t    if (!!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)) {\t\n\t    }else{\n\t        window.removeEventListener(\"resize\",onResize,false);\n\t    }\n});\n```"
  },
  {
    title: '折叠留言楼层，递归无线循环',
    classId: '6121250a9929b4514cdbc1cd',
    tags: ['613a11a18d9fd118d82f2f08'],
    isRecommend: 1,
    isHot: 1,
    state: 1,
    content: "研究了一下递归循环，展示留言评论功能，如图\n\n![image.png](https://upload-images.jianshu.io/upload_images/13238271-95bbeb822809d81c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n代码部分：基于jquery开发\n\n> js部分\n\n```js\n $(function(){\n        var array = [\n            {id:1,name:'张一',time:'2017-12-06',data:[\n                {id:2,name:'张二',time:'2017-12-06',\n                    data:[\n                        {id:22,name:'张三',time:'2017-12-06'},{id:23,name:'张四',time:'2017-12-06'}\n                    ]\n                },\n                {id:3,name:'张五',time:'2017-12-06'}\n            ]},\n            {id:4,name:'张刘曼',time:'2017-12-06',data:[\n                {id:5,name:'张六',time:'2017-12-06'},{id:6,name:'张七',time:'2017-12-06'}\n            ]},\n            {id:7,name:'张吧',time:'2017-12-06',data:[\n                {id:8,name:'张就',time:'2017-12-06'},{id:9,name:'张是',time:'2017-12-06'}\n            ]},\n            {id:10,name:'张三一',time:'2017-12-06',data:[\n                {id:11,name:'张三二',time:'2017-12-06'},{id:12,name:'张三撒',time:'2017-12-06'}\n            ]},\n            {id:13,name:'张三四',time:'2017-12-06',data:[\n                {id:14,name:'张三五',time:'2017-12-06'},{id:15,name:'张三六',time:'2017-12-06'}\n            ]},\n            {id:16,name:'张三七',time:'2017-12-06'},\n            {id:17,name:'张三吧',time:'2017-12-06'},\n            {id:18,name:'张三就',time:'2017-12-06'}\n        ];\n        var html = '',sw = 1;\n        listShow(array);\n        $('.messageBox').append(html);\n        function listShow(array){\n            for(var i = 0;i<array.length; i++){\n                if(array[i].data){\n                    html+=`<li>\n                    <div>\n                    <span><i class=\"zheicon comicon\"></i>${array[i].id}</span>\n                    <span>${array[i].name}</span>\n                    <span>好漂亮</span>\n                    <span>${array[i].time}</span>\n                    </div><ul>`;\n                    //递归回调\n                    listShow(array[i].data);\n                    html+='</ul></li>';\n                }else{\n                    html+=`<li>\n                   <div>\n                       <span>${array[i].id}</span>\n                       <span>${array[i].name}</span>\n                       <span>好漂亮</span>\n                        <span>${array[i].time}</span>\n                        </div></li>`;\n                }\n            }\n        }\n        //点击展开\n        $('.messageBox').on('click','.zheicon',function(){\n            var zheBox = $(this).parent().parent().siblings('ul');\n            if($(zheBox).hasClass('show')){\n                $(zheBox).removeClass('show');\n            }else{\n                $(zheBox).addClass('show');\n            }\n        });\n\n    })\n```\n\n> html部分\n\n```html\n<ul class=\"messageBox\">\n    <li class=\"msg-head\">\n        <div class=\"\">\n            <span>ID</span>\n            <span>评论人</span>\n            <span>评论内容</span>\n            <span>评论时间</span>\n        </div>\n    </li>\n</ul>\n```\n\n> CSS部分\n\n```css\n.messageBox {\n  width: 100%;\n  height: auto;\n  position: relative;\n  padding: 0;\n  margin: 0;\n  box-sizing: border-box;\n  border: 1px solid #eee;\n  overflow: visible;\n}\n.messageBox li {\n  width: 100%;\n  padding-left: 30px;\n  box-sizing: border-box;\n  list-style-type: none;\n  position: relative;\n  background: #fff;\n  transition: background 0.3s ease;\n}\n.messageBox li div {\n  width: 100%;\n  padding-left: 30px;\n  box-sizing: border-box;\n  position: relative;\n}\n.messageBox li div span {\n  width: 25%;\n  height: 40px;\n  line-height: 40px;\n  box-sizing: border-box;\n  float: left;\n}\n.messageBox li div:after {\n  content: '';\n  display: block;\n  clear: both;\n}\n.messageBox li li:nth-child(odd) {\n  background: transparent;\n}\n.messageBox li li:last-child {\n  border-bottom: none;\n}\n.messageBox li ul {\n  display: none;\n  margin: 0;\n  padding: 0;\n}\n.messageBox li ul li {\n  background: transparent;\n}\n.messageBox li ul.show {\n  display: block;\n}\n.messageBox li .zheicon {\n  display: inline-block;\n  width: 0px;\n  height: 0px;\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-top: 8px solid#2f2f2f;\n  position: absolute;\n  left: 8px;\n  top: 15px;\n}\n.messageBox li:nth-child(odd) {\n  background: #f8f8f8;\n}\n.messageBox .msg-head {\n  background: #f8f8f8;\n}\n\n```"
  }
];

module.exports = list;
